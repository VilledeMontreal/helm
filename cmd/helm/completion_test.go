// Add a build tag because these tests cannot be run in the same
// fashion as all the others.  With a build tag to ignore them
// they will not be included in the full test suite.
// But when explicitly specified, they will ignore the build tag
// and will be run.
// See the Makefile for how to run them (make test-completion).
//
// +build ignore_for_generic_test_run

/*
Copyright The Helm Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"fmt"
	"os/exec"
	"strings"
	"testing"
)

// This file will be generated by the Makefile (make test-completion)
// It would have been nice to generate the script by calling the
// completion file, but for that to work, it requires the Root command,
// which then requires the inclusion of all other files to be able
// to run the completion tests.
// Using the makefile simplifies things greatly.
const helmCompletionScript = "/tmp/helm_completion.bash"

func runCompletionForTest(t *testing.T, commandToComplete string, expected string) {
	t.Helper()
	t.Run("", func(t *testing.T) {
    	cmd := exec.Command("../../scripts/completion-test.bash",
    		helmCompletionScript,
    		"helm "+commandToComplete)

		output, err := cmd.Output()
    	if err != nil {
    		t.Fatal(err)
    	}

    	result := strings.TrimSpace(string(output))
    	if result != expected {
    		t.Errorf("\nExpected %q\ngot %q", expected, result)
    	}
    })
}

// No need to test every command as completion is handled
// automatically by Cobra.
// We focus on some smoke tests for the Cobra-handled completion
// and on helm-specific features.

func TestFirstLevelComplete(t *testing.T) {
	// Basic first level commands (static completion)
	runCompletionForTest(t, "r", "registry repo rollback")
	runCompletionForTest(t, "re", "registry repo")
	runCompletionForTest(t, "stat", "status")
	runCompletionForTest(t, "status", "status")
	runCompletionForTest(t, "lis", "list")
}
func TestSecondLevelComplete(t *testing.T) {
	// Basic second level commands (static completion)
	runCompletionForTest(t, "get ", "hooks manifest values")
	runCompletionForTest(t, "get h", "hooks")
	runCompletionForTest(t, "completion ", "bash zsh")
	runCompletionForTest(t, "completion z", "zsh")
}
func TestFirstLevelAliasComplete(t *testing.T) {
	// Alias completion
	// Does not work.
	//runCompletionForTest(t, "ls", "ls")
	//runCompletionForTest(t, "dependenci", "dependencies")
}
func TestDynamicReleaseComplete(t *testing.T) {
	// Output of a single release
	result := "rel206"
	runCompletionForTest(t, "status rel206", result)

	// Output of multiple releases with prefix
	result = "rel1"
	for i := 0; i < 10; i++ {
		result += fmt.Sprintf(" rel1%d", i)
		for j := 0; j < 10; j++ {
			result += fmt.Sprintf(" rel1%d%d", i, j)
		}
	}
	runCompletionForTest(t, "status rel1", result)

	// Output of multiple releases without prefix
	result = "rel0"
	// Releases 1 to the limit used in the completion logic (1000)
	for i := 1; i < 30; i++ {
		result += fmt.Sprintf(" rel%d", i)
		for j := 0; j < 10; j++ {
			result += fmt.Sprintf(" rel1%d%d", i, j)
		}
	}
	runCompletionForTest(t, "status ", result)

}
